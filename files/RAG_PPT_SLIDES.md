# RAG 임베딩 모델 PPT 슬라이드

---

## 페이지 1: 왜 RAG를 도입했는가?

### 제목: "레이아웃 추천 시스템의 한계와 RAG 도입"

---

### 1. 기존 시스템의 문제점

#### 💡 핵심 과제: "디자이너 입력에 맞는 잡지 레이아웃을 자동으로 추천하라"

#### 기존 방식 (Rule-based)
```python
# layouts.py - 레이아웃 정의
LAYOUTS = {
    "hero": {"image_ratio": 0.7, "text_position": "bottom"},
    "split": {"image_ratio": 0.5, "text_position": "side"},
    ...
}

# components.py - 구성요소 정의
COMPONENTS = {
    "headline": {"font_size": "4xl", "weight": "bold"},
    "body": {"font_size": "base", "line_height": 1.6},
    ...
}
```

#### 선택 알고리즘
```
if image_count == 1:
    layout = "hero"
elif image_count == 2:
    layout = "split"
else:
    layout = "grid"  # 단순 조건문 기반
```

---

### 2. 기존 방식의 한계

| 문제점 | 상세 |
|:---|:---|
| **알고리즘 한계** | 조건문으로는 "Elegant", "Luxurious" 같은 **추상적 Mood** 반영 불가 |
| **확장성 부족** | 새로운 레이아웃 추가 시 코드 전체 수정 필요 |
| **성능 저하** | 디자이너 의도와 동떨어진 결과물 빈출 |
| **유연성 부재** | 사진/본문의 시각적 특성을 고려하지 못함 |

---

### 3. RAG 도입으로 해결

| Before (Rule-based) | After (RAG) |
|:---|:---|
| `if-else` 조건문 | **벡터 유사도 검색** |
| 코드에 레이아웃 하드코딩 | **52개 실제 잡지 레이아웃 DB** |
| Mood 반영 불가 | **Elegant, Vibrant 등 의미 검색** |
| 확장 시 코드 수정 | **DB에 레이아웃 추가만** |

### 핵심 전환
> **"조건문 기반 선택"** → **"디자이너 의도와 가장 유사한 레이아웃 검색"**

---


---

## 페이지 2: MRL + ChromaDB 구현

### 제목: "MRL과 벡터 검색 최적화"

---

### 1. MRL (Matryoshka Representation Learning) 이란?

**러시아 마트료시카 인형**처럼 벡터를 **중첩 구조**로 학습

```
┌────────────────────────────────────────────────────────────┐
│  일반 임베딩                                                │
│  [████████████████████████████████] 2048차원               │
│                                                            │
│  ✗ 앞부분만 자르면 → 정보 손실, 성능 급락                    │
└────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────┐
│  MRL 임베딩                                                 │
│                                                            │
│  [██████|████████|████████████|████████████████]           │
│   256    512      1024         2048                        │
│   핵심   +추가     +세부        +미세                        │
│                                                            │
│  ✓ 512차원만 사용해도 → 핵심 정보 유지, 성능 97%            │
└────────────────────────────────────────────────────────────┘
```

---

### 2. 성능 비교 (MTEB Retrieval)

| 차원 | 일반 임베딩 | MRL 임베딩 | 성능 유지율 |
|:---:|:---:|:---:|:---:|
| 2048 | 0.85 | 0.85 | 100% |
| 1024 | 0.70 | **0.84** | 99% |
| **512** | 0.55 | **0.82** | **97%** ← 우리 선택 |
| 256 | 0.35 | 0.78 | 92% |

**우리 시스템**: 512차원 선택
- 정확도 97% 유지
- 검색 속도 4배 향상
- 저장 공간 75% 절약

---

### 3. ChromaDB 설정

| 설정 | 값 | 설명 |
|:---|:---|:---|
| 유사도 | **Dot Product** | 정규화된 벡터에서 Cosine과 동일 |
| 알고리즘 | **HNSW** | O(log N) 검색 복잡도 |
| 저장 | 영구 저장 | `./chroma_db_voyage` |

```python
collection = client.get_or_create_collection(
    name="magazine_layouts_voyage",
    metadata={"hnsw:space": "ip"}  # Inner Product
)
```

---

### 4. 검색 흐름 (Cascading Fallback)

```
┌─────────────────────────────────────────────────────────────┐
│ 1. 쿼리 임베딩                                               │
│    "Professional Beauty Skincare" → [0.23, -0.15, ...]     │
└───────────────────────────┬─────────────────────────────────┘
                            │
┌───────────────────────────▼─────────────────────────────────┐
│ 2. 필터 적용 (Cascading Fallback)                            │
│                                                             │
│    시도 1: {type: Article, image_count: 3, ratio: Vertical} │
│    → 0 results                                              │
│                                                             │
│    시도 2: {type: Article, image_count: 3}                  │
│    → 0 results                                              │
│                                                             │
│    시도 3: {type: Article}                                  │
│    → 2 results ✓                                            │
└───────────────────────────┬─────────────────────────────────┘
                            │
┌───────────────────────────▼─────────────────────────────────┐
│ 3. 벡터 유사도 검색 (Dot Product)                            │
│    query · doc_vectors → Top-5 결과                         │
└───────────────────────────┬─────────────────────────────────┘
                            │
┌───────────────────────────▼─────────────────────────────────┐
│ 4. 결과 반환                                                 │
│    [{id: "layout_042", similarity: 0.89, mood: "Clean"}]   │
└─────────────────────────────────────────────────────────────┘
```

---

## 요약

| 페이지 | 핵심 메시지 |
|:---|:---|
| **1** | RAG로 검색 + 생성 결합, Voyage 3.5 선택 이유 |
| **2** | MRL로 효율적 임베딩, ChromaDB로 빠른 검색 |
| **3-1** | 모델 비교표 (벤치마크) |
| **3-2** | 우리 데이터 특성 분석 |
| **3-3** | 4단계 선정 로직 |
| **3-4** | 최종 결론: Voyage 3.5 |

---

## 페이지 3-1: 모델 비교표

### 제목: "RAG Reference - 임베딩 모델 벤치마크"

| Rank | Model | Memory | EmbeddingDims | Retrieval | STS |
|:---:|:---|:---:|:---:|:---:|:---:|
| 12 | **Voyage 3.5** | API | 512~2048 | 64.01 | 69.97 |
| 1 | KaLM-Gemma3-12B | 44884 | 3840 | 75.66 | 79.02 |
| 6 | gemini-embedding-001 | API | 3072 | 67.71 | 79.40 |
| 10 | Seed1.6-embedding | API | 2048 | 66.05 | 75.92 |
| 11 | Qwen3-0.6B | 1136 | 1024 | 64.65 | 76.17 |

**핵심 질문**: "왜 1등 모델을 안 쓰고 12등 모델을 썼는가?"

---

## 페이지 3-2: 우리 데이터의 특성

### 제목: "복잡한 디자인 JSON 구조 분석"

| 항목 | 값 |
|:---|:---|
| 총 레이아웃 수 | **52개** (Cover, Article) |
| 평균 요소 수 | **10.7개**/레이아웃 |
| 정밀 좌표 | **4개** (x1, y1, x2, y2) per element |
| Mood 종류 | **10종** (Elegant, Luxurious, Vibrant...) |
| Category | **10개** (fashion, beauty, lifestyle...) |
| Description | 평균 **52단어** |

**핵심 구조**: 메타데이터 + 공간좌표 + 텍스트 = 계층적 복합 구조

**인사이트**: MRL 기술로 이 복잡한 구조를 **512차원**에 효율적으로 압축 가능

---

## 페이지 3-3: 4단계 선정 로직

### 제목: "합리적 모델 선정을 위한 필터링"

| Step | 기준 | 결과 |
|:---:|:---|:---|
| 1 | **Retrieval 우선** | 상위권 후보 추출 |
| 2 | **STS 검증** | inf-retriever, jina 탈락 (지표 누락) |
| 3 | **인프라 제약** | Qwen3-0.6B 탈락 (로컬 GPU 필요) |
| 4 | **MRL & Latency** | **Voyage 3.5** 최종 선택! |

---

## 페이지 3-4: 최종 결론

### 제목: "왜 Voyage 3.5인가?"

| 비교 항목 | Gemini-001 / Seed1.6 | **Voyage 3.5** |
|:---|:---:|:---:|
| 차원 | 2048~3072 | **512** (MRL) |
| 검색 속도 | 느림 | **4배+ 빠름** |
| 성능 손실 | 차원 줄이면 급락 | **97% 유지** |
| 인프라 | API/로컬 혼합 | **순수 API** |
| 비용 | 유료 | **200M 토큰 무료** |

### 핵심 메시지
> **"512차원으로도 우리 데이터는 충분하다."**
> MRL 덕분에 성능은 대등하고, Latency는 압도적으로 빠르다.

---

